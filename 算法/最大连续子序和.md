# 最大连续子序和

给定一个整数数组，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

## 1. 动态规划解法

```javascript
function maxSubArray(nums) {
    if (!nums.length) return 0;
    
    let dp = nums[0];  // dp[i] 表示以 nums[i] 结尾的最大子序和
    let max = dp;      // 记录全局最大值
    
    for (let i = 1; i < nums.length; i++) {
        // 状态转移方程：dp[i] = Math.max(nums[i], dp[i-1] + nums[i])
        dp = Math.max(nums[i], dp + nums[i]);
        max = Math.max(max, dp);
    }
    
    return max;
}

// 测试
console.log(maxSubArray([-2,1,-3,4,-1,2,1,-5,4])); // 输出: 6 ([4,-1,2,1])
```

## 2. 贪心算法解法

```javascript
function maxSubArray(nums) {
    if (!nums.length) return 0;
    
    let currentSum = nums[0];
    let maxSum = currentSum;
    
    for (let i = 1; i < nums.length; i++) {
        // 如果当前和为负数，就重新开始计算
        currentSum = Math.max(nums[i], currentSum + nums[i]);
        maxSum = Math.max(maxSum, currentSum);
    }
    
    return maxSum;
}
```

## 3. 分治法解法

```javascript
function maxSubArray(nums) {
    return maxSubArrayHelper(nums, 0, nums.length - 1);
}

function maxSubArrayHelper(nums, left, right) {
    if (left === right) return nums[left];
    
    const mid = Math.floor((left + right) / 2);
    
    // 计算左半部分的最大子序和
    const leftSum = maxSubArrayHelper(nums, left, mid);
    // 计算右半部分的最大子序和
    const rightSum = maxSubArrayHelper(nums, mid + 1, right);
    // 计算跨越中点的最大子序和
    const crossSum = maxCrossingSum(nums, left, mid, right);
    
    return Math.max(leftSum, rightSum, crossSum);
}

function maxCrossingSum(nums, left, mid, right) {
    // 计算包含左边界的最大和
    let leftSum = 0;
    let maxLeftSum = -Infinity;
    for (let i = mid; i >= left; i--) {
        leftSum += nums[i];
        maxLeftSum = Math.max(maxLeftSum, leftSum);
    }
    
    // 计算包含右边界的最大和
    let rightSum = 0;
    let maxRightSum = -Infinity;
    for (let i = mid + 1; i <= right; i++) {
        rightSum += nums[i];
        maxRightSum = Math.max(maxRightSum, rightSum);
    }
    
    return maxLeftSum + maxRightSum;
}
```

## 4. 空间优化的动态规划解法

```javascript
function maxSubArray(nums) {
    if (!nums.length) return 0;
    
    let maxSoFar = nums[0];
    let maxEndingHere = nums[0];
    
    for (let i = 1; i < nums.length; i++) {
        maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);
        maxSoFar = Math.max(maxSoFar, maxEndingHere);
    }
    
    return maxSoFar;
}
```

## 时间复杂度分析

1. 动态规划解法：O(n)
2. 贪心算法解法：O(n)
3. 分治法解法：O(n log n)
4. 空间优化的动态规划解法：O(n)

## 空间复杂度分析

1. 动态规划解法：O(1)
2. 贪心算法解法：O(1)
3. 分治法解法：O(log n) - 递归调用栈的空间
4. 空间优化的动态规划解法：O(1)

## 应用场景

1. 股票交易：计算最大收益区间
2. 信号处理：寻找信号的最强区间
3. 数据分析：查找数据的最大增长区间
4. 图像处理：寻找图像中最亮的连续区域

## 注意事项

1. 处理空数组的边界情况
2. 处理全是负数的情况
3. 处理只有一个元素的情况
4. 考虑数值范围，防止整数溢出
