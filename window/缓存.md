# 缓存
当用户端向服务器发起请求资源的时，会先抵达浏览器缓存，如果浏览器有要求资源的副本，就可以直接从浏览器缓存中提取，而不是从原始服务器中提权这个资源

http缓存都是从第二次请求开始。第一次请求资源时，服务器返回资源，并在response header头中回传资源的缓存参数；第二次请求时，浏览器去判断这些请求，命中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否命中协商缓存，命中则返回304，否则浏览就返回新的资源。

常见的http缓存只能缓存get请求响应的资源。

## 强缓存
浏览器在第一次向服务器发送请求时，若服务器觉得该资源需要缓存，这时候服务器会在response-header终添加字段,cache-contol，如设置max-age,此时浏览器就会在本地缓存保存相应的文件。

在浏览器下一次请求同样的文件时，浏览器会检查本地文件的max-age 是否过期，如果没有过期，就直接从缓存里面获取资源，不会向服务器发起请求，这样子就能提升页面的加载速度，如果max-age过期，那么浏览就又会像第一次一样向浏览器发起请求。 


这种方式页面加载速度是最快的，性能也是最好的。但是在这期间，如果服务器资源有更新，页面是拿不到最新的资源的，因为它不会再向服务发送请求。只用进行强制刷新ctrl+F5 就好了

form memory cache 代表使用内存中的缓存，from disk cache 代表使用的磁盘中的缓存。浏览器取缓存的顺序为memory -> disk。在浏览器中，浏览器会在js和图片等文件解析完毕后存入内存缓存中，那么当刷新页面时只需要直接从内存缓存中读取（from memory cahce）而css 文件则会存入磁盘中，所以每次渲染页面都需要从磁盘读取缓存（from disk
 cache）

### 强缓存header 属性

- Expires：这是http1.0的规范，他的值是一个绝对时间（GMT格式的时间字符传）如果请求时间在expries之前，那么本地缓存是在有效期
- Cache-Control：是http1.1出现的header信息，主要是利用max-age字段的值来进行判断，它是一个相对值，需要计算出什么时间点过期，然后跟当前时间进行比较，如果请求时间在过期时间之前，就能命中强缓存

| **选项** | **解释** |
| --- | --- |
| max-age=100 |缓存在100s后过期，资源缓存在本地 |
| no-cache | 不使用本地缓存，使用协商缓存 |
| no-store | 不使用任何缓存 |
| public | 可以被所有的用户缓存，包括客户端和代理服务器 |
| private |  只能被单个用户缓存，通常是用户浏览器，代理服务器则无法缓存 |

如果cache-control 与expries同时存在，cache-control优先级高。

## 协商缓存

强缓存失效后，浏览器携带标志想服务器发起请求，服务器根据标志判断是否使用缓存的过程

浏览器再次发起请求该资源的时候，浏览器会向服务器发送请求和资源标识，服务器就会判断当前请求的资源，和本地缓存的资源版本是否一致，

- 如果版本一致，服务器就会返回304状态码，重定向让浏览器直接在本地缓存里面找
- 如果版本不一致，服务器就会返回200状态码，最新的资源以及新资源的标识，浏览器更新本地缓存。
- 资源标识
  - Last-Modified/If-Modified-Since：指资源上一次修改的时间
  - ETag/If-None-Match：资源对应的唯一字符串

服务器会为每个资源生成唯一的标识字符串，只要文件内容不同，他们对应的ETag就是不同的。

If-Modified-Since 只能检测到的精度是秒级的，且只要编辑了文件，即使文件没有改变，都会改变文件的最后修改时间，导致重新请求资源。

Etag优先级高于Last-Modified